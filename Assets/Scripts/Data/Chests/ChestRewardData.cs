using Assets.Scripts.Menu.MainMenu.MainTab.Chests;
using Enums;
using Game.Managers;
using Inventory;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using Tools;
using UnityEngine;

namespace Data
{
    [Serializable]
    public struct SSpellDistributionData
    {
        [Description("Type of spell that is generated by this distribution")]
        public ERarety Rarety;
        [Description("Minimum cards generated")]
        public int MinAmount;
        [Description("Maximum cards generated")]
        public int MaxAmount;

        public SSpellDistributionData(ERarety rarety, int minAmount, int maxAmount)
        {
            Rarety = rarety;
            MinAmount = minAmount;
            MaxAmount = maxAmount;
        }

        public SReward Generate()
        {
            return new SReward(
                ERewardType.Spell,
                UnityEngine.Random.Range(MinAmount, MaxAmount), 
                new Dictionary<string, object> () { { SReward.METADATA_KEY_SPELL_TYPE, GenerateRandomSpell(Rarety) } }
            );
        }

        ESpell GenerateRandomSpell(ERarety rarety)
        {
            var spells = SpellLoader.GetSpellsFromRarety(rarety);
            return spells[UnityEngine.Random.Range(0, spells.Count)].Spell;
        }
    }

    [CreateAssetMenu(fileName = "ChestRewardData", menuName = "Game/ChestRewardData")]
    public class ChestRewardData : ScriptableObject
    {
        [Header("Identity")]
        public EChestType ChestType;
        public Sprite Image;
        public int UnlockTime;

        [Header("Collectables")]
        public int[] Golds = new int[2];
        public SSpellDistributionData[] SpellsDistribution;


        #region Public Manipulators

        public List<SReward> GetRewards()
        {
            List<SReward> rewards = new();

            foreach (SSpellDistributionData spellDistribution in SpellsDistribution)
            {
                rewards.Add(spellDistribution.Generate());
            }

            rewards.Add(new SReward(ERewardType.Golds, UnityEngine.Random.Range(Golds[0], Golds[1])));
            
            return rewards;
        }

        public ChestUI Instantiate(GameObject parent, bool scale = true)
        {
            ChestUI chestUI = GameObject.Instantiate(AssetLoader.LoadChestPrefab(ChestType), parent.transform).GetComponent<ChestUI>();
            chestUI.Initialize();

            // calculate scale of container and update accordingly
            if (scale)
                CoroutineManager.DelayMethod(() => { ScaleOfParent(ref chestUI, parent); });

            // update render value
            UpdateRenderOrder(ref chestUI, parent);

            return chestUI;
        }

        void ScaleOfParent(ref ChestUI chestUI, GameObject parent)
        {
            // get min scaling
            RectTransform parentRectT = Finder.FindComponent<RectTransform>(parent);
            float minScale = Mathf.Min(parentRectT.rect.width / chestUI.Icon.bounds.size.x, parentRectT.rect.height / chestUI.Icon.bounds.size.y);
            
            chestUI.transform.localScale = new Vector3(minScale, minScale, 1f);
        }

        /// <summary>
        /// Find base canvas from parent where this game object is instantiated and update the render order to be above
        /// </summary>
        /// <param name="chestUI"></param>
        /// <param name="parent"></param>
        void UpdateRenderOrder(ref ChestUI chestUI, GameObject parent)
        {
            // Find the parent Canvas component
            Canvas canvas = FindParentCanvasComponent(parent.transform);

            // if no canvas : no need to update render order
            if (canvas == null)
                return;

            // Get all SpriteRenderer components in the hierarchy of the Chest object
            var spriteRenderers = Finder.FindComponents<SpriteRenderer>(chestUI.gameObject, throwError: false);

            // Adjust the sorting order of SpriteRenderer components
            foreach (SpriteRenderer spriteRenderer in spriteRenderers)
            {
                spriteRenderer.sortingLayerName = canvas.sortingLayerName;
                spriteRenderer.sortingOrder += canvas.sortingOrder + 1; // Render above the Canvas
            }

            // Get all ParticleSystem components in the hierarchy of the Chest object
            var particleSystems = Finder.FindComponents<ParticleSystem>(chestUI.gameObject, throwError: false);

            // Adjust the rendering order of ParticleSystem components
            foreach (ParticleSystem particleSystem in particleSystems)
            {
                Renderer particleRenderer = particleSystem.GetComponent<Renderer>();
                if (particleRenderer != null)
                {
                    particleRenderer.sortingLayerName = canvas.sortingLayerName;
                    particleRenderer.sortingOrder += canvas.sortingOrder + 1; // Render above the Canvas
                }
            }
        }

        Canvas FindParentCanvasComponent(Transform currentTransform)
        {
            // Base case: If current transform is null, return null
            if (currentTransform == null)
            {
                return null;
            }

            // Check if the current transform's parent has a Canvas component
            Canvas parentCanvas = currentTransform.parent?.GetComponent<Canvas>();

            // If parentCanvas is null, recursively search the parent's parent
            if (parentCanvas == null)
            {
                return FindParentCanvasComponent(currentTransform.parent);
            }

            // If parentCanvas is not null, return it
            return parentCanvas;
        }

        #endregion
    }
}